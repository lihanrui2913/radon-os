pub const MICROKERNEL_SYSCALL_BASE: usize = 0x80000000;

pub const SYS_LOG: usize = MICROKERNEL_SYSCALL_BASE + 0x0;

// Handle 操作
pub const SYS_HANDLE_CLOSE: usize = MICROKERNEL_SYSCALL_BASE + 0x1;
pub const SYS_HANDLE_DUPLICATE: usize = MICROKERNEL_SYSCALL_BASE + 0x2;
pub const SYS_HANDLE_INFO: usize = MICROKERNEL_SYSCALL_BASE + 0x3;

// Port 操作
pub const SYS_PORT_CREATE: usize = MICROKERNEL_SYSCALL_BASE + 0x10;
pub const SYS_PORT_WAIT: usize = MICROKERNEL_SYSCALL_BASE + 0x11;
pub const SYS_PORT_BIND: usize = MICROKERNEL_SYSCALL_BASE + 0x12;
pub const SYS_PORT_UNBIND: usize = MICROKERNEL_SYSCALL_BASE + 0x13;
pub const SYS_PORT_QUEUE: usize = MICROKERNEL_SYSCALL_BASE + 0x14;

// Channel 操作
pub const SYS_CHANNEL_CREATE: usize = MICROKERNEL_SYSCALL_BASE + 0x20;
pub const SYS_CHANNEL_SEND: usize = MICROKERNEL_SYSCALL_BASE + 0x21;
pub const SYS_CHANNEL_RECV: usize = MICROKERNEL_SYSCALL_BASE + 0x22;
pub const SYS_CHANNEL_TRY_RECV: usize = MICROKERNEL_SYSCALL_BASE + 0x23;
pub const SYS_CHANNEL_CALL: usize = MICROKERNEL_SYSCALL_BASE + 0x24;

// 时间
pub const SYS_CLOCK_GET: usize = MICROKERNEL_SYSCALL_BASE + 0x30;
pub const SYS_NANOSLEEP: usize = MICROKERNEL_SYSCALL_BASE + 0x31;

// 进程/线程
pub const SYS_PROCESS_CREATE: usize = MICROKERNEL_SYSCALL_BASE + 0x40;
pub const SYS_PROCESS_START: usize = MICROKERNEL_SYSCALL_BASE + 0x41;
pub const SYS_THREAD_CREATE: usize = MICROKERNEL_SYSCALL_BASE + 0x42;
pub const SYS_EXIT: usize = MICROKERNEL_SYSCALL_BASE + 0x43;
pub const SYS_YIELD: usize = MICROKERNEL_SYSCALL_BASE + 0x44;
pub const SYS_PROCESS_GET_INIT_HANDLE: usize = MICROKERNEL_SYSCALL_BASE + 0x45;
pub const SYS_PROCESS_WAIT: usize = MICROKERNEL_SYSCALL_BASE + 0x46;
pub const SYS_PROCESS_GET_VMAR_HANDLE: usize = MICROKERNEL_SYSCALL_BASE + 0x47;

// 内存操作
pub const SYS_VMO_CREATE: usize = MICROKERNEL_SYSCALL_BASE + 0x60;
pub const SYS_VMO_CREATE_PHYSICAL: usize = MICROKERNEL_SYSCALL_BASE + 0x61;
pub const SYS_VMO_CREATE_CHILD: usize = MICROKERNEL_SYSCALL_BASE + 0x62;
pub const SYS_VMO_READ: usize = MICROKERNEL_SYSCALL_BASE + 0x63;
pub const SYS_VMO_WRITE: usize = MICROKERNEL_SYSCALL_BASE + 0x64;
pub const SYS_VMO_GET_SIZE: usize = MICROKERNEL_SYSCALL_BASE + 0x65;
pub const SYS_VMO_SET_SIZE: usize = MICROKERNEL_SYSCALL_BASE + 0x66;
pub const SYS_VMO_GET_PHYS: usize = MICROKERNEL_SYSCALL_BASE + 0x67;

pub const SYS_VMAR_MAP: usize = MICROKERNEL_SYSCALL_BASE + 0x70;
pub const SYS_VMAR_UNMAP: usize = MICROKERNEL_SYSCALL_BASE + 0x71;
pub const SYS_VMAR_PROTECT: usize = MICROKERNEL_SYSCALL_BASE + 0x72;

pub const SYS_GET_TID: usize = MICROKERNEL_SYSCALL_BASE + 0x100;
pub const SYS_GET_PID: usize = MICROKERNEL_SYSCALL_BASE + 0x101;

pub const SYS_LOAD_TASK_REGISTERS: usize = MICROKERNEL_SYSCALL_BASE + 0x110;
pub const SYS_STORE_TASK_REGISTERS: usize = MICROKERNEL_SYSCALL_BASE + 0x111;

pub const SYS_KRES_GET_RSDP: usize = MICROKERNEL_SYSCALL_BASE + 0x200;

#[cfg(target_arch = "x86_64")]
pub const SYS_KRES_GET_FSBASE: usize = MICROKERNEL_SYSCALL_BASE + 0x1000;
#[cfg(target_arch = "x86_64")]
pub const SYS_KRES_SET_FSBASE: usize = MICROKERNEL_SYSCALL_BASE + 0x1001;
